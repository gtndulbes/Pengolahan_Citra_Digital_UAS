# ============================================
# PRE-PROCESSING & SEGMENTASI X-RAY COVID
# FULL VERSION + VISUALISASI PIPELINE
# ============================================

import cv2
import numpy as np
import os
import matplotlib.pyplot as plt

# --------------------------------------------
# PATH DATASET
# --------------------------------------------
DATASET_PATH = "dataset"
OUTPUT_PATH = "output_segmentation"
PIPELINE_PATH = "output_pipeline"

CLASSES = ["covid", "normal"]

# Buat folder output
for cls in CLASSES:
    os.makedirs(os.path.join(OUTPUT_PATH, cls), exist_ok=True)

os.makedirs(PIPELINE_PATH, exist_ok=True)

# --------------------------------------------
# FUNGSI PRE-PROCESSING
# --------------------------------------------
def load_resize(img_path, size=(256,256)):
    img = cv2.imread(img_path)
    if img is None:
        return None
    original = img.copy()
    resized = cv2.resize(img, size)
    return original, resized

def to_gray(img):
    return cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

def denoise(gray):
    return cv2.medianBlur(gray, 5)

# --------------------------------------------
# FUNGSI SEGMENTASI
# --------------------------------------------
def otsu_threshold(img):
    _, binary = cv2.threshold(
        img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU
    )
    return binary

def morphology(binary):
    kernel = np.ones((5,5), np.uint8)
    opening = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)
    closing = cv2.morphologyEx(opening, cv2.MORPH_CLOSE, kernel)
    return closing

def extract_roi(gray, binary):
    contours, _ = cv2.findContours(
        binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
    )

    if len(contours) == 0:
        return gray

    largest = max(contours, key=cv2.contourArea)
    x, y, w, h = cv2.boundingRect(largest)
    roi = gray[y:y+h, x:x+w]
    return roi

# --------------------------------------------
# FUNGSI VISUALISASI PIPELINE
# --------------------------------------------
def save_pipeline(original, resized, gray, clean,
                  binary, morph, roi, filename):

    plt.figure(figsize=(14,8))

    images = [original, resized, gray, clean,
              binary, morph, roi]

    titles = ["Original",
              "Resize 256x256",
              "Grayscale",
              "Median Filter",
              "Otsu Threshold",
              "Morphology",
              "ROI"]

    for i in range(len(images)):
        plt.subplot(2,4,i+1)

        if len(images[i].shape) == 3:
            plt.imshow(cv2.cvtColor(images[i], cv2.COLOR_BGR2RGB))
        else:
            plt.imshow(images[i], cmap='gray')

        plt.title(titles[i])
        plt.axis("off")

    plt.tight_layout()
    save_path = os.path.join(PIPELINE_PATH,
                             f"pipeline_{filename}.png")
    plt.savefig(save_path, dpi=300)
    plt.close()

# --------------------------------------------
# PIPELINE UTAMA
# --------------------------------------------
print("üîÑ Memulai Pre-processing & Segmentasi...")

for cls in CLASSES:
    input_folder = os.path.join(DATASET_PATH, cls)
    output_folder = os.path.join(OUTPUT_PATH, cls)

    for file in os.listdir(input_folder):

        img_path = os.path.join(input_folder, file)

        if not os.path.isfile(img_path) or file.startswith('.'):
            continue

        result = load_resize(img_path)
        if result is None:
            print(f"‚ö†Ô∏è Gagal load: {file}")
            continue

        original, resized = result

        # Pre-processing
        gray = to_gray(resized)
        clean = denoise(gray)

        # Segmentasi
        binary = otsu_threshold(clean)
        morph = morphology(binary)
        roi = extract_roi(clean, morph)

        # Simpan ROI
        save_roi_path = os.path.join(output_folder, file)
        cv2.imwrite(save_roi_path, roi)

        # Simpan Pipeline (untuk jurnal)
        save_pipeline(original, resized, gray,
                      clean, binary, morph, roi, file)

print("‚úÖ SELESAI!")
print("üìÅ ROI tersimpan di: output_segmentation/")
print("üì∑ Pipeline gambar tersimpan di: output_pipeline/")
